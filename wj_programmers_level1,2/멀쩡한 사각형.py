def gcd(a,b):
    m = min(a,b)
    for i in range(m, 0, -1):
        if (a%i) + (b%i) == 0:
            return i
    
def solution(w,h):
    
    minus = w+h -gcd(w,h)
    print(gcd(w,h))
    answer = w*h-minus
    return answer

'''
    첫시도 : answer = w*h - math.ceil(h/w)*w. 예시만 보고 생각하느라 너무 단순하게 했다;
    
    두번째 시도 : 비율 b= m1/m2 (긴변/짧은변) 해서
    t=0을 b씩 늘림. t+b가 1보다 작으면 정사각형 1 추가, 1이면 1 추가하고 t-1해주고, 1 초과하면 정사각형 2 추가하고 t-1 해주고.. 이 짓을 긴변 만큼 해준다. 분수를 생각하고 짰는데 여기서는 b가 float형태라서 1/3+2/3 이 0.99999이런식으로 나오니까 1/3+2/3 ==1에 걸리지를 않았다. 또 시간복잡도도 꽝.
    
    결국 답 참고 : 최대공약수를 이용.
    최대공약수로 나눈 w', h'가 있다. 
    대각선은 반대쪽 코너에 도달하기전 w'-1 세로선과 h'-1 가로선을 지나고 지날때마다 새로운 정사각형이 추가됩니다. 그래서 첫 정사각형을 포함 1 + (w'-1) + (h'-1) = w' + h' - 1개의 정사각형을 지나게 되므로 공약수를 다시 곱해주면 w + h - gcd(w,h)개의 정사각형을 지나는것을 찾을수있습니다.
    
    흠.. 마지막 줄 설명이 잘 이해가 가지 않는다...

'''
'''
재귀를 이용한 최대공약수
def gcd(a, b):
    return b if a % b == 0 else gcd(b, a % b)

'''
